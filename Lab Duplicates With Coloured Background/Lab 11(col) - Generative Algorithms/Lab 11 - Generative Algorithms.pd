#N canvas 2142 84 474 469 12;
#X obj 1 2 cnv 15 2000 2000 empty empty empty 20 12 0 14 -203904 -66577
0;
#N canvas 91 25 828 634 MarkovChains 0;
#X obj 0 -1 cnv 15 2000 2000 empty empty empty 20 12 0 14 -203904 -66577
0;
#X obj 4 140 cnv 15 800 250 empty empty empty 20 12 0 14 -228856 -66577
0;
#X obj 3 3 cnv 15 800 30 empty empty Markov_Chain 20 12 0 20 -233017
-66577 0;
#X text 18 39 Markov chains are systems that transition from one state
to another according to probability-based rules. We can create them
using the kind of chance-based mechanism we saw in the previous example:
, f 107;
#X obj 20 86 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0 1
;
#X obj 22 464 hsl 280 30 -20 120 0 0 empty empty empty -2 -8 0 10 -262144
-1 -1 0 1;
#X obj 55 498 bng 15 250 50 0 empty MC1 empty 17 7 0 10 -262144 -1
-1;
#X obj 255 498 bng 15 250 50 0 empty MC2 empty 17 7 0 10 -262144 -1
-1;
#X obj 38 149 r state;
#X obj 20 175 f 1;
#X obj 20 199 select 1 2, f 56;
#X obj 20 223 bng 15 250 50 0 MC1 empty empty 17 7 0 10 -262144 -1
-1;
#X obj 20 290 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X msg 50 309 1;
#X obj 125 290 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X msg 85 309 2;
#X obj 214 223 bng 15 250 50 0 MC2 empty empty 17 7 0 10 -262144 -1
-1;
#X obj 214 290 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X msg 244 309 1;
#X obj 319 290 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X msg 279 309 2;
#X obj 61 338 s state;
#X obj 256 338 s state;
#N canvas 238 83 450 300 retrigger2 0;
#X obj 47 26 inlet;
#X obj 47 56 t b b;
#X obj 47 165 outlet;
#X obj 157 84 del 150;
#X msg 47 121 100 \, 120 100;
#X msg 157 121 120 \, 100 100;
#X connect 0 0 1 0;
#X connect 1 0 4 0;
#X connect 1 1 3 0;
#X connect 3 0 5 0;
#X connect 4 0 2 0;
#X connect 5 0 2 0;
#X restore 319 416 pd retrigger2;
#X obj 20 246 ABprob;
#X obj 214 246 ABprob;
#N canvas 238 83 450 300 retrigger1 0;
#X obj 47 26 inlet;
#X obj 47 56 t b b;
#X obj 47 165 outlet;
#X obj 157 84 del 150;
#X msg 47 121 0 \, -20 100;
#X msg 157 121 -20 \, 0 100;
#X connect 0 0 1 0;
#X connect 1 0 4 0;
#X connect 1 1 3 0;
#X connect 3 0 5 0;
#X connect 4 0 2 0;
#X connect 5 0 2 0;
#X restore 19 416 pd retrigger1;
#N canvas 238 83 450 300 1-2 0;
#X obj 47 26 inlet;
#X obj 47 165 outlet;
#X obj 47 56 t b;
#X msg 47 121 0 \, 100 200;
#X connect 0 0 2 0;
#X connect 2 0 3 0;
#X connect 3 0 1 0;
#X restore 125 415 pd 1-2;
#N canvas 238 83 450 300 2-1 0;
#X obj 47 26 inlet;
#X obj 47 165 outlet;
#X obj 47 56 t b;
#X msg 47 121 100 \, 0 200;
#X connect 0 0 2 0;
#X connect 2 0 3 0;
#X connect 3 0 1 0;
#X restore 214 416 pd 2-1;
#X obj 19 441 line;
#X obj 56 517 simpleHat~;
#X obj 256 517 simpleHat~;
#X obj 155 571 dac~;
#X obj 56 540 *~ 0.1;
#X obj 256 540 *~ 0.1;
#X text 115 85 <- Start the generator;
#X text 117 150 <- The previous state determines which of the two "CHANCE"
abstractions are used, f 63;
#X text 421 197 <- route to one of the "CHANCE" abstractions, f 20
;
#X text 421 257 <- probabilities decide the future state of the system
, f 20;
#X text 421 337 <- send new state back to top, f 20;
#X text 573 149 This grey section is the Markov chain \, with each
new bang a new state is generated depending on the previous state.
Each previous state will give a different set of probabilities for
the next outcome., f 31;
#X text 573 269 Try changing the two sliders in the "CHANCE" abstractions
to see how these probabilities influence the behaviour of the system.
, f 31;
#X text 574 414 <- This is just some stuff that lets you see/hear the
system behaviour more clearly., f 31;
#X obj 20 104 metro 250;
#X connect 4 0 43 0;
#X connect 6 0 30 0;
#X connect 7 0 31 0;
#X connect 8 0 9 1;
#X connect 9 0 10 0;
#X connect 10 0 11 0;
#X connect 10 1 16 0;
#X connect 11 0 24 0;
#X connect 12 0 13 0;
#X connect 12 0 26 0;
#X connect 13 0 21 0;
#X connect 14 0 15 0;
#X connect 14 0 27 0;
#X connect 15 0 21 0;
#X connect 16 0 25 0;
#X connect 17 0 18 0;
#X connect 17 0 28 0;
#X connect 18 0 22 0;
#X connect 19 0 20 0;
#X connect 19 0 23 0;
#X connect 20 0 22 0;
#X connect 23 0 29 0;
#X connect 24 0 12 0;
#X connect 24 1 14 0;
#X connect 25 0 17 0;
#X connect 25 1 19 0;
#X connect 26 0 29 0;
#X connect 27 0 29 0;
#X connect 28 0 29 0;
#X connect 29 0 5 0;
#X connect 30 0 33 0;
#X connect 31 0 34 0;
#X connect 33 0 32 0;
#X connect 34 0 32 1;
#X connect 43 0 9 0;
#X restore 24 306 pd MarkovChains;
#N canvas 1440 25 1920 1027 EuclideanRhythms 1;
#X obj 3 3 cnv 15 1200 30 empty empty Euclidian_Rhythms 20 12 0 20
-233017 -66577 0;
#X obj 4 47 beatclock 120;
#X obj 236 140 f;
#X obj 276 140 + 1;
#X text 307 141 <- create a count;
#X obj 236 107 spigot;
#X obj 286 107 == 0;
#X obj 275 72 tgl 15 0 empty empty empty 17 7 0 10 -204800 -1 -1 0
1;
#X obj 98 159 s ER-16thNotes;
#X obj 51 179 s ER-4thNotes;
#X obj 236 48 r ER-16thNotes;
#X obj 236 171 % 16;
#X obj 236 282 *;
#X obj 236 309 % 16;
#X obj 236 339 <;
#X text 344 276 <- number of notes to play in loop;
#X obj 236 367 tgl 15 0 ERcurState empty empty 17 7 0 10 -262144 -1
-1 0 1;
#X obj 46 384 r ER-16thNotes;
#X obj 46 407 simplehat~;
#X obj 236 456 vol-ctl~;
#X obj 236 496 dac~;
#X obj 236 404 sel 1;
#X obj 236 430 simpleSnare~;
#X text 175 78 pass or block bangs->, f 7;
#X text 299 72 <- play/stop rhythm;
#X text 319 107 <- reset when stopped/started;
#X text 275 171 <- make a 16 beat loop;
#X obj 236 195 nbx 4 20 -1e+37 1e+37 0 0 ERloopCount empty empty 0
-8 0 12 -262144 -1 -1 0 256;
#X obj 285 276 nbx 4 20 -1e+37 1e+37 0 1 ERnotes empty empty 0 -8 0
12 -204800 -1 -1 7 256;
#N canvas 120 25 1221 640 visualiseLoop 0;
#X obj 4 17 hradio 15 1 0 16 empty ERloopCount empty 0 -8 0 10 -191407
-261682 -261682 14;
#X obj 4 33 tgl 15 0 empty ER1 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 19 33 tgl 15 0 empty ER2 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 34 33 tgl 15 0 empty ER3 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 49 33 tgl 15 0 empty ER4 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 64 33 tgl 15 0 empty ER5 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 79 33 tgl 15 0 empty ER6 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 94 33 tgl 15 0 empty ER7 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 109 33 tgl 15 0 empty ER8 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 124 33 tgl 15 0 empty ER9 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 139 33 tgl 15 0 empty ER10 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 154 33 tgl 15 0 empty ER11 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 169 33 tgl 15 0 empty ER12 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 184 33 tgl 15 0 empty ER13 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 199 33 tgl 15 0 empty ER14 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 214 33 tgl 15 0 empty ER15 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X obj 229 33 tgl 15 0 empty ER16 empty 17 7 0 10 -33289 -33289 -33289
0 1;
#X text 31 -1 Euclidian Algorithm Output;
#X obj 137 81 r ERcurState;
#X obj 137 104 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0
1;
#X floatatom 98 102 5 0 0 0 - - -;
#X obj 41 81 r ERloopCount;
#X obj 98 126 pack f f;
#X obj 98 317 route 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15;
#X obj 98 346 s ER1;
#X obj 116 366 s ER2;
#X obj 135 386 s ER3;
#X obj 152 406 s ER4;
#X obj 172 346 s ER5;
#X obj 190 366 s ER6;
#X obj 209 386 s ER7;
#X obj 226 406 s ER8;
#X obj 247 346 s ER9;
#X obj 265 366 s ER10;
#X obj 284 386 s ER11;
#X obj 301 406 s ER12;
#X obj 321 346 s ER13;
#X obj 339 366 s ER14;
#X obj 358 386 s ER15;
#X obj 375 406 s ER16;
#X obj 462 99 r ERnotes;
#X obj 462 142 t b;
#X msg 462 322 0;
#X obj 532 99 r ERoffset;
#X obj 284 204 sel 0 1;
#X obj 226 237 f;
#X obj 266 237 f;
#X obj 245 151 unpack;
#X msg 508 322 color 12 12 12;
#X obj 284 184 pipe 5;
#X msg 137 263 \$1 color 20 0 0;
#X msg 262 263 \$1 color 4 12 12;
#X connect 18 0 19 0;
#X connect 19 0 22 1;
#X connect 20 0 22 0;
#X connect 21 0 20 0;
#X connect 22 0 47 0;
#X connect 22 0 23 0;
#X connect 23 0 24 0;
#X connect 23 1 25 0;
#X connect 23 2 26 0;
#X connect 23 3 27 0;
#X connect 23 4 28 0;
#X connect 23 5 29 0;
#X connect 23 6 30 0;
#X connect 23 7 31 0;
#X connect 23 8 32 0;
#X connect 23 9 33 0;
#X connect 23 10 34 0;
#X connect 23 11 35 0;
#X connect 23 12 36 0;
#X connect 23 13 37 0;
#X connect 23 14 38 0;
#X connect 23 15 39 0;
#X connect 40 0 41 0;
#X connect 41 0 42 0;
#X connect 41 0 48 0;
#X connect 42 0 39 0;
#X connect 42 0 38 0;
#X connect 42 0 37 0;
#X connect 42 0 36 0;
#X connect 42 0 35 0;
#X connect 42 0 34 0;
#X connect 42 0 33 0;
#X connect 42 0 32 0;
#X connect 42 0 31 0;
#X connect 42 0 30 0;
#X connect 42 0 29 0;
#X connect 42 0 28 0;
#X connect 42 0 24 0;
#X connect 42 0 25 0;
#X connect 42 0 26 0;
#X connect 42 0 27 0;
#X connect 43 0 41 0;
#X connect 44 0 45 0;
#X connect 44 1 46 0;
#X connect 45 0 50 0;
#X connect 46 0 51 0;
#X connect 47 0 45 1;
#X connect 47 0 46 1;
#X connect 47 1 49 0;
#X connect 48 0 39 0;
#X connect 48 0 38 0;
#X connect 48 0 37 0;
#X connect 48 0 36 0;
#X connect 48 0 35 0;
#X connect 48 0 34 0;
#X connect 48 0 33 0;
#X connect 48 0 32 0;
#X connect 48 0 31 0;
#X connect 48 0 30 0;
#X connect 48 0 29 0;
#X connect 48 0 28 0;
#X connect 48 0 27 0;
#X connect 48 0 26 0;
#X connect 48 0 25 0;
#X connect 48 0 24 0;
#X connect 49 0 44 0;
#X connect 50 0 23 0;
#X connect 51 0 23 0;
#X coords 0 -1 1 1 250 50 2 0 0;
#X restore 729 322 pd visualiseLoop;
#X obj 236 244 +;
#X obj 285 226 nbx 4 20 -1e+37 1e+37 0 1 ERoffset empty empty 0 -8
0 12 -204800 -1 -1 0 256;
#X text 344 226 <- offset pattern;
#X text 642 48 Here's an example of a Euclydian Rhythm generator. The
algorithm will take the number of notes you want to play in a given
loop \, and try to space them out as evenly as possible.;
#X obj 123 407 r ER-4thNotes;
#X obj 122 429 FMkick~ 70 150;
#X obj 46 430 *~ 0.35;
#X text 642 128 Because not all numbers will divide perfectly into
the length of the loop \, we end up with some nice syncopated rhythms.
;
#X text 642 188 The example hear spreads a given number of notes accross
a loop of 16 semiquavers. You may also notice that the rhythms we end
up with are similar to those found in different musical traditions
from around the world.;
#X text 642 268 Have a play around with the blue number boxes and see/hear
the results!;
#N canvas 151 25 1289 847 EuclydianKit 0;
#X obj 106 105 euclid32;
#X obj 106 145 euclid32;
#X obj 106 185 euclid32;
#X text 831 113 HAT;
#X text 831 193 KICK;
#X text 831 153 SNARE;
#X obj 41 67 r ER-16thNotes;
#X obj 27 237 s ERkik;
#X obj 27 197 s ERsnr;
#X obj 27 157 s ERhat;
#X obj 908 105 simpleHat~;
#X obj 984 105 simpleSnare~;
#X obj 1075 105 FMkick~ 50 250;
#X obj 908 67 r ERhat;
#X obj 984 67 r ERsnr;
#X obj 1075 67 r ERkik;
#X obj 907 249 *~;
#X obj 938 249 *~;
#X obj 969 249 *~;
#X obj 885 289 outlet~;
#X connect 0 0 9 0;
#X connect 0 1 16 1;
#X connect 1 0 8 0;
#X connect 1 1 17 1;
#X connect 2 0 7 0;
#X connect 2 1 18 1;
#X connect 6 0 1 0;
#X connect 6 0 0 0;
#X connect 6 0 2 0;
#X connect 10 0 16 0;
#X connect 11 0 17 0;
#X connect 12 0 18 0;
#X connect 13 0 10 0;
#X connect 14 0 11 0;
#X connect 15 0 12 0;
#X connect 16 0 19 0;
#X connect 17 0 19 0;
#X connect 18 0 19 0;
#X coords 0 -1 1 1 780 130 2 100 100;
#X restore 233 597 pd EuclydianKit;
#X obj 233 730 vol-ctl~;
#X obj 233 770 dac~;
#X text 233 562 Using the same kind of algorithm \, we can expand this
into larger sequencers that generate complex cross rhythms. In this
case \, we can now set 3 independent loops of varying length., f 111
;
#X connect 1 2 9 0;
#X connect 1 4 8 0;
#X connect 2 0 3 0;
#X connect 2 0 11 0;
#X connect 3 0 2 1;
#X connect 5 0 2 0;
#X connect 6 0 2 1;
#X connect 7 0 6 0;
#X connect 7 0 5 1;
#X connect 10 0 5 0;
#X connect 11 0 27 0;
#X connect 12 0 13 0;
#X connect 13 0 14 0;
#X connect 14 0 16 0;
#X connect 16 0 21 0;
#X connect 17 0 18 0;
#X connect 18 0 36 0;
#X connect 19 0 20 0;
#X connect 19 0 20 1;
#X connect 21 0 22 0;
#X connect 22 0 19 0;
#X connect 27 0 30 0;
#X connect 28 0 12 1;
#X connect 28 0 14 1;
#X connect 30 0 12 0;
#X connect 31 0 30 1;
#X connect 34 0 35 0;
#X connect 35 0 19 0;
#X connect 36 0 19 0;
#X connect 40 0 41 0;
#X connect 41 0 42 0;
#X connect 41 0 42 1;
#X restore 24 246 pd EuclideanRhythms;
#N canvas 559 149 474 548 Chance 0;
#X obj 0 1 cnv 15 2000 2000 empty empty empty 20 12 0 14 -203904 -66577
0;
#X obj 3 3 cnv 15 450 30 empty empty Chance 20 12 0 20 -233017 -66577
0;
#X text 22 40 In this example \, we either take action A or B \, depending
on a given probability...;
#X obj 115 202 moses, f 6;
#X obj 45 163 random 101;
#X obj 45 107 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X text 195 159 <- Generate a number from 0<100;
#X obj 154 107 nbx 3 15 0 100 0 1 empty empty empty 0 -8 0 12 -262144
-1 -1 50 256;
#X obj 72 299 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X text 195 199 <- Split output depending on whether input is smaller
or greater than a threshold, f 31;
#X floatatom 72 275 5 0 0 0 - - -;
#X obj 182 299 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X floatatom 182 275 5 0 0 0 - - -;
#X text 52 317 ACTION A;
#X text 162 317 ACTION B;
#X text 23 359 This can be bundled into an abstraction like this one
\, wich will bias the output in the direction of the slider:;
#X obj 45 429 metro 200;
#X obj 45 401 tgl 15 0 empty empty empty 17 7 0 10 -262144 -1 -1 0
1;
#X obj 45 453 ABprob;
#X obj 45 493 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144 -1
-1;
#X obj 150 493 bng 15 250 50 0 empty empty empty 17 7 0 10 -262144
-1 -1;
#X connect 3 0 10 0;
#X connect 3 1 12 0;
#X connect 4 0 3 0;
#X connect 5 0 4 0;
#X connect 7 0 3 1;
#X connect 10 0 8 0;
#X connect 12 0 11 0;
#X connect 17 0 16 0;
#X restore 24 276 pd Chance;
#X obj 3 3 cnv 15 450 60 empty empty Generative_Algorithms 20 12 0
30 -233017 -66577 0;
#X text 22 67 More ways to get Pd to play automatically. This patch
goes past the random examples from the previous lab and introduces
the idea of making music based on rules.;
#X obj 24 125 beatclock 120;
#X text 170 127 <- We'll also use this [beatclock 120] abstraction
to give us subdivisions and multiples of a tempo, f 22;
#N canvas 78 25 909 601 PuttingItTogether 0;
#X obj 0 0 cnv 15 2000 2000 empty empty empty 20 12 0 14 -203904 -66577
0;
#X obj 6 535 vol-ctl~;
#X obj 6 575 dac~;
#N canvas 32 25 1246 788 GenerativeDrumSequencer 0;
#X obj -1 0 cnv 15 2000 2000 empty empty empty 20 12 0 14 -203904 -66577
0;
#X obj 1130 81 loadbang;
#X msg 1130 105 120;
#X obj 72 332 simpleHat~;
#X obj 191 149 tgl 15 0 allSTART empty empty 17 7 0 10 -262144 -1 -1
0 1;
#X obj 73 356 *~;
#X obj 191 172 GenerativeStrip;
#X text 207 147 START EVERYTHING!;
#X floatatom 337 147 5 0 0 0 - - allTEMPO;
#X text 376 147 ALL TEMPOS;
#X obj 1194 133 r allTEMPO;
#X obj 134 81 r allSTART;
#X obj 191 312 GenerativeStrip;
#X obj 191 452 GenerativeStrip;
#X obj 75 494 *~;
#X obj 78 649 *~;
#X obj 74 470 simpleSnare~;
#X obj 77 625 FMKick~ 80 250;
#X obj 154 720 outlet~;
#X connect 1 0 2 0;
#X connect 2 0 8 0;
#X connect 2 0 12 1;
#X connect 2 0 13 1;
#X connect 3 0 5 0;
#X connect 5 0 18 0;
#X connect 10 0 12 1;
#X connect 10 0 13 1;
#X connect 11 0 12 0;
#X connect 11 0 13 0;
#X connect 12 0 16 0;
#X connect 12 1 14 1;
#X connect 13 0 17 0;
#X connect 13 1 15 1;
#X connect 14 0 18 0;
#X connect 15 0 18 0;
#X connect 16 0 14 0;
#X connect 17 0 15 0;
#X coords 0 -1 1 1 880 450 2 180 140;
#X restore 6 79 pd GenerativeDrumSequencer;
#X obj 3 3 cnv 15 900 30 empty empty Putting_It_All_Together 20 12
0 20 -233017 -66577 0;
#X text 22 41 This example may look complicated \, but it only uses
the elements from the other examples given in this weeks lab \, have
a play around with it \, and look what's under the hood if you're curious!
, f 125;
#X connect 1 0 2 0;
#X connect 1 0 2 1;
#X restore 24 336 pd PuttingItTogether;
#X text 21 367 Bear in mind that this is just a tiny introduction to
rule based (algorithmic) music generation \, there are a huge range
of other ways to go about it!;
#X text 179 244 <-- generate rhythmic patterns;
#X text 179 276 <-- use probabilities in your patches;
#X text 179 306 <-- networks of probabilistic rules;
#X text 179 336 <-- putting these together;
