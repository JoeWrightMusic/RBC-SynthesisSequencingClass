#N canvas 721 98 458 566 12;
#N canvas 137 53 459 687 loadASoundFileToABuffer 0;
#N canvas 32 25 450 278 (subpatch) 0;
#X array soundFile 205120 float 2 black black;
#X coords 0 1 205120 -1 200 140 1;
#X restore 20 256 graph;
#X obj 18 91 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc #000000
#000000;
#X obj 18 111 openpanel;
#X obj 18 159 soundfiler;
#X floatatom 18 206 15 0 0 0 - - -, f 15;
#X msg 18 135 read -resize \$1 soundFile;
#X obj 3 3 cnv 15 450 30 empty empty Load_a_Sound_File 20 12 0 20 #e0e0e0
#404040 0;
#X text 14 40 Use the button to open up a file broweser \, then choose
your sound file, f 29;
#X text 127 205 <-- length of the sound file in samples;
#X text 227 265 <-- length of the sound file in samples, f 29;
#X text 94 111 <-- opens file browser;
#X text 203 135 <-- read the file and resize the array called soundFile
, f 33;
#X text 17 417 This can be reused as an abstraction \, we just need
to make sure that the name of the array is either unique (using \$0)
\, or that it uses a name from a creation argument (using \$1 \, \$2
\, \$3 etc);
#X obj 19 487 buffer soundFileAbstraction;
#X connect 1 0 2 0;
#X connect 2 0 5 0;
#X connect 3 0 4 0;
#X connect 5 0 3 0;
#X restore 23 169 pd loadASoundFileToABuffer;
#X obj 3 3 cnv 15 450 60 empty empty Working_With_Samples 20 12 0 30
#e0e0e0 #404040 0;
#X text 21 70 This lab presents a few examples that can get you started
with using samples and soundfiles when synthesising or sequencing sounds
in Pd.;
#X text 21 130 First \, we need to load our sample to a buffer \, so
that we can access it in pd.;
#X text 22 206 Now we can create a simple one-shot sample player;
#N canvas 495 31 808 491 oneShotSampler 0;
#X obj 25 68 buffer;
#X floatatom 25 281 10 0 0 0 - - -, f 10;
#X obj 475 278 vline~;
#X obj 238 301 s buf;
#X obj 493 308 r buf;
#X obj 475 351 tabread4~;
#X obj 521 207 f;
#X obj 579 207 f;
#X obj 637 207 f;
#X obj 491 158 bng 15 250 50 0 empty empty empty 17 7 0 10 #ffffff
#000000 #000000;
#X obj 25 302 s bufFrames;
#X floatatom 539 157 5 0 1 0 - - -, f 5;
#X floatatom 597 157 5 2 10000 0 - - -, f 5;
#X floatatom 655 157 5 0 0 0 - - -, f 5;
#X text 536 132 Start;
#X text 599 132 Dur;
#X text 652 132 Speed;
#N canvas 85 29 1084 714 Calculate 0;
#X obj 181 29 inlet;
#X obj 90 29 inlet;
#X obj 266 29 inlet;
#X text 265 4 Speed;
#X obj 10 302 f;
#X obj 70 302 f;
#X obj 230 302 f;
#X obj 230 326 > 0;
#X obj 10 332 pack, f 9;
#X msg 270 350 1 \$1;
#X obj 270 375 -;
#X obj 10 399 spigot;
#X obj 128 399 spigot;
#X obj 88 452 +;
#X obj 205 452 -;
#X obj 10 452 unpack f f;
#X obj 128 452 unpack f f;
#X obj 83 571 pack f f f;
#X obj 83 665 outlet;
#N canvas 515 252 251 196 ms2samps 0;
#X obj 94 19 r pd-dsp-started;
#X obj 94 43 samplerate~;
#X obj 94 107 t b f;
#X obj 95 143 *;
#X obj 30 17 inlet;
#X obj 94 176 outlet;
#X obj 94 70 / 1000;
#X connect 0 0 1 0;
#X connect 1 0 6 0;
#X connect 2 0 3 0;
#X connect 2 1 3 1;
#X connect 3 0 5 0;
#X connect 4 0 3 0;
#X connect 6 0 2 0;
#X restore 180 207 pd ms2samps;
#N canvas 515 252 403 355 bufRange 0;
#X obj 95 143 *;
#X obj 30 17 inlet;
#X obj 94 176 outlet;
#X obj 95 18 r bufFrames;
#X obj 95 42 t b f;
#X connect 0 0 2 0;
#X connect 1 0 0 0;
#X connect 3 0 4 0;
#X connect 4 0 0 0;
#X connect 4 1 0 1;
#X restore 90 249 pd bufRange;
#X obj 181 179 *;
#X obj 216 121 t b f;
#X text 527 105 <- Multiply the number of samps to be read based on
speed. This keeps the duration of the one-shot samp consistent, f
34;
#X text 527 178 <- buf range changes the 0-1 position control into
a position in samples, f 33;
#X text 532 331 If speed is >0 \, ramp forwards in the sample \, if
the speed is <0 \, ramp backwards., f 33;
#X msg 82 615 \$1 \, \$2 \$3;
#X text 165 564 Pack values together to be formatted by a message,
f 37;
#X text 169 614 Format to template: "start \, end time";
#X text 180 4 Dur (ms);
#X text 90 4 Start (0-1);
#X obj 801 120 - 20;
#X msg 801 144 1 20 \, 0 20 \$1;
#X obj 801 168 outlet;
#X text 135 663 Read output;
#X text 854 169 Env output;
#X obj 10 29 inlet;
#X text 10 4 Trigger;
#X obj 801 98 f;
#X obj 213 155 abs;
#X obj 440 303 f;
#X obj 10 249 t b b b b;
#X text 527 237 <- the trigger ensures we always use the latest values
from each inlet to make the ramp message, f 33;
#X text 938 97 <- Add a short fade in & fade out to avoid clicks when
playing back a sample, f 19;
#X connect 0 0 21 0;
#X connect 0 0 38 1;
#X connect 0 0 40 1;
#X connect 1 0 20 0;
#X connect 2 0 22 0;
#X connect 4 0 8 0;
#X connect 5 0 8 1;
#X connect 6 0 7 0;
#X connect 7 0 9 0;
#X connect 7 0 11 1;
#X connect 8 0 11 0;
#X connect 8 0 12 0;
#X connect 9 0 10 0;
#X connect 10 0 12 1;
#X connect 11 0 13 0;
#X connect 11 0 15 0;
#X connect 12 0 14 0;
#X connect 12 0 16 0;
#X connect 13 0 17 1;
#X connect 14 0 17 1;
#X connect 15 0 17 0;
#X connect 16 0 17 0;
#X connect 17 0 26 0;
#X connect 19 0 5 1;
#X connect 20 0 4 1;
#X connect 21 0 19 0;
#X connect 22 0 21 0;
#X connect 22 1 6 1;
#X connect 22 1 39 0;
#X connect 26 0 18 0;
#X connect 31 0 32 0;
#X connect 32 0 33 0;
#X connect 36 0 38 0;
#X connect 36 0 41 0;
#X connect 38 0 31 0;
#X connect 39 0 21 1;
#X connect 40 0 17 2;
#X connect 41 0 4 0;
#X connect 41 1 5 0;
#X connect 41 2 6 0;
#X connect 41 3 40 0;
#X restore 475 234 pd Calculate Ramp & Env;
#X text 647 234 <- this is where the work is being done, f 21;
#X obj 633 346 vline~;
#X obj 475 391 *~;
#X text 476 132 Trig;
#X obj 3 3 cnv 15 800 30 empty empty One-Shot_Sample_Player 20 12 0
20 #e0e0e0 #404040 0;
#X text 21 39 Trigger a one-shot region of a sample;
#X text 321 236 vline creates a ramp that moves the 'playhead' accross
the sample buffer ->, f 21;
#X text 322 321 'playhead' looks up the value of a sample in the soundfile->
, f 21;
#X text 255 93 <-- LOAD UP A SOUND FILE FIRST;
#X text 681 345 <- a second vline adds a short fade in and out to prevent
clicks, f 15;
#X msg 493 329 set \$1-array;
#X obj 441 428 output~;
#X obj 598 61 loadbang;
#X msg 655 97 1;
#X msg 597 97 1000;
#X connect 0 0 1 0;
#X connect 0 1 3 0;
#X connect 1 0 10 0;
#X connect 2 0 5 0;
#X connect 4 0 28 0;
#X connect 5 0 20 0;
#X connect 6 0 17 1;
#X connect 7 0 17 2;
#X connect 8 0 17 3;
#X connect 9 0 8 0;
#X connect 9 0 7 0;
#X connect 9 0 6 0;
#X connect 9 0 17 0;
#X connect 11 0 6 1;
#X connect 12 0 7 1;
#X connect 13 0 8 1;
#X connect 17 0 2 0;
#X connect 17 1 19 0;
#X connect 19 0 20 1;
#X connect 20 0 29 0;
#X connect 20 0 29 1;
#X connect 28 0 5 0;
#X connect 30 0 32 0;
#X connect 30 0 31 0;
#X connect 31 0 13 0;
#X connect 32 0 12 0;
#X restore 23 226 pd oneShotSampler;
#X text 22 264 With a few alterations \, we can loop the sample-segments
;
#N canvas 390 104 809 440 sampleLooper 0;
#X obj 25 68 buffer;
#X floatatom 459 157 5 0 1 0 - - -, f 5;
#X floatatom 517 157 5 2 10000 0 - - -, f 5;
#X floatatom 575 157 5 0 0 0 - - -, f 5;
#X text 456 132 Start;
#X text 519 132 Dur;
#X text 572 132 Speed;
#X obj 3 3 cnv 15 800 30 empty empty Sample_Looper 20 12 0 20 #e0e0e0
#404040 0;
#X text 255 93 <-- LOAD UP A SOUND FILE FIRST;
#X obj 431 276 grain~, f 16;
#X obj 238 281 s loopBuf;
#X obj 518 251 r loopBuf;
#X obj 539 299 s loopTrig;
#X obj 292 158 r loopTrig;
#X obj 372 157 tgl 15 0 empty empty empty 17 7 0 10 #ffffff #000000
#000000 0 1;
#X text 360 132 Loop;
#X obj 333 218 spigot;
#X msg 333 240 1;
#X text 21 39 Loop a region of a sample;
#X obj 416 158 bng 15 250 50 0 empty empty empty 17 7 0 10 #ffffff
#000000 #000000;
#X text 408 121 One-Shot, f 4;
#X obj 416 179 t b b;
#X msg 449 202 0;
#X msg 416 202 1;
#X obj 333 192 t b f;
#X text 630 44 The abstraction used here is almost identical to the
one-shot patch in the previous example. Inside \, we've added a delayed
trigger that is sent from the right outlet to mark when the segment
has finished playing. The trigger has been changed to take 0/1 (stop/play)
instead of a bang \, so that a segment can be stopped when the loop
is turned off. For now \, we're not using the last inlet \, which chooses
between two different types of window: the fade in and fade out that's
applied to the segment., f 23;
#X obj 376 343 output~;
#X obj 527 54 loadbang;
#X msg 527 83 1000;
#X msg 571 82 1;
#X connect 0 1 10 0;
#X connect 1 0 9 1;
#X connect 2 0 9 2;
#X connect 3 0 9 3;
#X connect 9 0 26 0;
#X connect 9 0 26 1;
#X connect 9 1 12 0;
#X connect 11 0 9 4;
#X connect 13 0 16 0;
#X connect 14 0 24 0;
#X connect 16 0 17 0;
#X connect 17 0 9 0;
#X connect 19 0 21 0;
#X connect 21 0 23 0;
#X connect 21 1 22 0;
#X connect 22 0 14 0;
#X connect 23 0 9 0;
#X connect 24 0 16 0;
#X connect 24 1 16 1;
#X connect 27 0 28 0;
#X connect 27 0 29 0;
#X connect 28 0 2 0;
#X connect 29 0 3 0;
#X restore 23 284 pd sampleLooper;
#X text 22 324 Assuming we have a sample that contains a perfect (in-time)
loop \, we can create a beat-chopper;
#N canvas 404 46 1008 783 beatChopper 0;
#X obj 25 68 buffer;
#X floatatom 409 567 5 0 1 0 - - -, f 5;
#X floatatom 467 567 5 2 10000 0 - - -, f 5;
#X floatatom 525 567 5 0 0 0 - - -, f 5;
#X text 409 542 Start;
#X text 469 542 Dur;
#X text 522 542 Speed;
#X obj 3 3 cnv 15 1000 30 empty empty Sample_Chopper 20 12 0 20 #e0e0e0
#404040 0;
#X obj 381 656 grain~, f 16;
#X obj 326 568 bng 15 250 50 0 empty empty empty 17 7 0 10 #ffffff
#000000 #000000;
#X msg 326 612 1;
#X obj 238 262 s chopBuf;
#X obj 25 264 s chopLoopLen;
#X obj 490 635 r chopBuf;
#X obj 326 335 metro;
#N canvas 515 252 251 206 samps2ms 0;
#X obj 94 19 r pd-dsp-started;
#X obj 94 43 samplerate~;
#X obj 94 107 t b f;
#X obj 30 17 inlet;
#X obj 94 176 outlet;
#X obj 94 70 / 1000;
#X obj 95 143 /;
#X connect 0 0 1 0;
#X connect 1 0 5 0;
#X connect 2 0 6 0;
#X connect 2 1 6 1;
#X connect 3 0 6 0;
#X connect 5 0 2 0;
#X connect 6 0 4 0;
#X restore 559 195 pd samps2ms;
#X obj 559 170 r chopLoopLen;
#X obj 326 174 tgl 15 0 empty empty empty 17 7 0 10 #ffffff #000000
#000000 0 1;
#X text 255 93 <-- LOAD UP AN IN-TIME LOOP (the "dNb_break" file included
in this folder will work);
#X obj 592 518 loadbang;
#X msg 592 540 1;
#X obj 358 314 r chopLen;
#X text 282 149 Play Chop Loop;
#X text 434 149 No.Chops;
#X obj 435 191 expr pow(2 \, $f1);
#X obj 435 170 hradio 15 0 1 7 empty empty empty 0 -8 0 10 #ffffff
#000000 #000000 6;
#X floatatom 435 215 5 0 0 0 - - -, f 5;
#X obj 559 249 /;
#X obj 559 306 s chopLen;
#X obj 435 235 s noChops;
#X obj 512 213 t b f;
#X obj 380 402 random;
#X obj 427 372 r noChops;
#X floatatom 380 428 5 0 0 0 - - -, f 5;
#X msg 427 445 1 \$1;
#X obj 427 469 /;
#X obj 380 495 *;
#X obj 458 521 r chopLen;
#X obj 254 228 s chopOff;
#X obj 257 613 r chopOff;
#X obj 254 198 sel 1;
#X obj 343 568 bng 15 250 50 0 empty empty empty 17 7 0 10 #fcfcfc
#000000 #000000;
#X text 660 169 <- Get length of loop;
#X text 660 199 <- convert samps - > ms;
#X text 662 253 <- get the length of a chopped segment;
#X text 21 39 Divide a loop into equal segments and scramble during
playback, f 68;
#X text 371 336 <- trigger a bang after each chop is played;
#X text 441 402 <- randomly choose a chopped segment;
#X obj 559 283 /;
#X obj 525 593 s chopSpeed;
#X obj 590 229 r chopSpeed;
#X obj 590 253 t b f;
#X obj 348 690 output~;
#X connect 0 0 12 0;
#X connect 0 1 11 0;
#X connect 1 0 8 1;
#X connect 2 0 8 2;
#X connect 3 0 49 0;
#X connect 3 0 8 3;
#X connect 8 0 52 0;
#X connect 8 0 52 1;
#X connect 8 1 41 0;
#X connect 9 0 10 0;
#X connect 10 0 8 0;
#X connect 13 0 8 4;
#X connect 14 0 9 0;
#X connect 14 0 31 0;
#X connect 15 0 27 0;
#X connect 16 0 15 0;
#X connect 17 0 14 0;
#X connect 17 0 40 0;
#X connect 19 0 20 0;
#X connect 20 0 3 0;
#X connect 21 0 14 1;
#X connect 24 0 26 0;
#X connect 24 0 30 0;
#X connect 25 0 24 0;
#X connect 26 0 29 0;
#X connect 27 0 48 0;
#X connect 30 0 27 0;
#X connect 30 1 27 1;
#X connect 31 0 33 0;
#X connect 32 0 31 1;
#X connect 32 0 34 0;
#X connect 33 0 36 0;
#X connect 34 0 35 0;
#X connect 35 0 36 1;
#X connect 36 0 1 0;
#X connect 37 0 2 0;
#X connect 39 0 8 0;
#X connect 40 1 38 0;
#X connect 48 0 28 0;
#X connect 50 0 51 0;
#X connect 51 0 48 0;
#X connect 51 1 48 1;
#X restore 23 358 pd beatChopper;
#X text 22 404 Or if we pack the [grain~] abstraction (based on the
one-shot example) into a [clone] \, we can use it for granular synthesis
- producing new sounds from clouds of small segments of a source sample!
;
#N canvas 177 56 958 765 granularSynth 1;
#X obj 25 68 buffer;
#X floatatom 326 531 5 0 1 0 - - -, f 5;
#X floatatom 386 531 5 2 10000 0 - - -, f 5;
#X floatatom 449 531 5 0 0 0 - - -, f 5;
#X obj 3 3 cnv 15 950 30 empty empty Granular_Synth 20 12 0 20 #e0e0e0
#404040 0;
#X text 255 93 <-- LOAD UP AN IN-TIME LOOP (the "dNb_break" file included
in this folder will work);
#X text 21 39 Divide a loop into equal segments and scramble during
playback, f 68;
#X msg 326 561 all \$1;
#X msg 386 561 all \$1;
#X msg 449 561 all \$1;
#X msg 514 561 all \$1;
#X obj 513 531 r granBuf;
#X obj 238 281 s granBuf;
#X msg 22 534 next \$1;
#X floatatom 238 260 5 0 0 0 - - -, f 5;
#X obj 591 531 loadbang;
#X msg 591 561 all 1;
#X obj 25 666 clone grain~ 256;
#N canvas 32 25 1125 702 controls 0;
#N canvas 32 25 450 347 phasor 0;
#X obj 225 102 hsl 150 30 0.001 10 1 0 \$0-freq empty Phasor 20 16
0 15 #fce0c4 #000000 #000000 0 1;
#X obj 225 136 hsl 150 10 0 1 0 0 empty \$0-output output 20 5 0 8
#e0c4fc #000000 #000000 0 1;
#X obj 68 180 phasor~;
#X obj 156 180 loadbang;
#X msg 156 204 1;
#X obj 156 265 snapshot~;
#X obj 156 228 metro 1;
#X obj 156 311 outlet;
#X obj 380 102 tgl 45 0 empty empty On/Off 4 23 0 10 #fce0c4 #000000
#000000 0 1;
#X obj 156 289 spigot;
#X connect 0 0 2 0;
#X connect 2 0 5 0;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 5 0 9 0;
#X connect 6 0 5 0;
#X connect 8 0 9 1;
#X connect 9 0 7 0;
#X connect 9 0 1 0;
#X coords 0 -1 1 1 210 50 1 220 100;
#X restore 276 34 pd phasor;
#N canvas 32 25 450 374 phasor 0;
#X obj 225 102 hsl 150 30 1 5000 1 0 \$0-freq empty Random 20 16 0
15 #fce0c4 #000000 #000000 0 1;
#X obj 225 136 hsl 150 10 0 1 0 0 empty \$0-output output 20 5 0 8
#e0c4fc #000000 #000000 0 1;
#X obj 51 32 loadbang;
#X msg 51 56 1;
#X obj 51 80 metro 1;
#X obj 51 242 outlet;
#X obj 51 104 random 1001;
#X obj 51 128 / 1000;
#X msg 51 176 \$1 \$2;
#X obj 51 152 pack f f;
#X obj 51 200 line;
#X obj 51 221 spigot;
#X obj 380 102 tgl 45 0 empty empty On/Off 4 23 0 10 #fce0c4 #000000
#000000 0 1;
#X connect 0 0 4 1;
#X connect 0 0 9 1;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 6 0 7 0;
#X connect 7 0 9 0;
#X connect 8 0 10 0;
#X connect 9 0 8 0;
#X connect 10 0 11 0;
#X connect 11 0 5 0;
#X connect 11 0 1 0;
#X connect 12 0 11 1;
#X coords 0 -1 1 1 210 50 1 220 100;
#X restore 276 86 pd phasor;
#N canvas 32 25 891 568 triggers 0;
#X obj 161 5 tgl 50 0 empty empty On/Off 6 26 0 10 #fce0c4 #000000
#000000 0 1;
#X obj 191 102 metro 100;
#X obj 7 5 hsl 150 20 1 5000 1 0 empty empty Trig_Interval 5 11 0 10
#fce0c4 #000000 #000000 0 1;
#X obj 7 25 hsl 150 20 0.1 5000 1 0 empty empty Randomness 5 11 0 10
#fce0c4 #000000 #000000 0 1;
#X obj 7 45 hsl 150 10 1 5000 1 0 empty empty Output_Interval 5 6 0
5 #e0c4fc #000000 #000000 0 1;
#X obj 272 104 +;
#X obj 191 158 random;
#X obj 211 5 bng 50 50 10 0 empty empty empty 17 7 0 10 #cccccc #dcdcdc
#000000;
#X obj 272 81 t b f;
#X obj 142 158 outlet;
#X connect 0 0 1 0;
#X connect 1 0 6 0;
#X connect 1 0 7 0;
#X connect 1 0 9 0;
#X connect 2 0 5 0;
#X connect 3 0 6 1;
#X connect 5 0 1 1;
#X connect 5 0 4 0;
#X connect 6 0 8 0;
#X connect 8 0 5 0;
#X connect 8 1 5 1;
#X coords 0 -1 1 1 265 60 1 0 0;
#X restore 7 33 pd triggers;
#N canvas 32 25 450 347 phasor 0;
#X obj 225 102 hsl 150 30 0.001 10 1 0 \$0-freq empty Phasor 20 16
0 15 #fce0c4 #000000 #000000 0 1;
#X obj 225 136 hsl 150 10 0 1 0 0 empty \$0-output output 20 5 0 8
#e0c4fc #000000 #000000 0 1;
#X obj 68 180 phasor~;
#X obj 156 180 loadbang;
#X msg 156 204 1;
#X obj 156 265 snapshot~;
#X obj 156 228 metro 1;
#X obj 156 311 outlet;
#X obj 380 102 tgl 45 0 empty empty On/Off 4 23 0 10 #fce0c4 #000000
#000000 0 1;
#X obj 156 289 spigot;
#X connect 0 0 2 0;
#X connect 2 0 5 0;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 5 0 9 0;
#X connect 6 0 5 0;
#X connect 8 0 9 1;
#X connect 9 0 7 0;
#X connect 9 0 1 0;
#X coords 0 -1 1 1 210 50 1 220 100;
#X restore 487 34 pd phasor;
#N canvas 32 25 450 374 phasor 0;
#X obj 225 102 hsl 150 30 1 5000 1 0 \$0-freq empty Random 20 16 0
15 #fce0c4 #000000 #000000 0 1;
#X obj 225 136 hsl 150 10 0 1 0 0 empty \$0-output output 20 5 0 8
#e0c4fc #000000 #000000 0 1;
#X obj 51 32 loadbang;
#X msg 51 56 1;
#X obj 51 80 metro 1;
#X obj 51 242 outlet;
#X obj 51 104 random 1001;
#X obj 51 128 / 1000;
#X msg 51 176 \$1 \$2;
#X obj 51 152 pack f f;
#X obj 51 200 line;
#X obj 51 221 spigot;
#X obj 380 102 tgl 45 0 empty empty On/Off 4 23 0 10 #fce0c4 #000000
#000000 0 1;
#X connect 0 0 4 1;
#X connect 0 0 9 1;
#X connect 2 0 3 0;
#X connect 3 0 4 0;
#X connect 4 0 6 0;
#X connect 6 0 7 0;
#X connect 7 0 9 0;
#X connect 8 0 10 0;
#X connect 9 0 8 0;
#X connect 10 0 11 0;
#X connect 11 0 5 0;
#X connect 11 0 1 0;
#X connect 12 0 11 1;
#X coords 0 -1 1 1 210 50 1 220 100;
#X restore 488 90 pd phasor;
#N canvas 32 25 450 374 phasor 0;
#X obj 225 102 hsl 150 30 1 10000 1 0 \$0-freq empty Length 20 16 0
15 #fce0c4 #000000 #000000 0 1;
#X obj 225 136 hsl 150 10 1 10000 1 0 empty \$0-output output 20 5
0 8 #e0c4fc #000000 #000000 0 1;
#X obj 134 276 outlet;
#X obj 380 102 tgl 45 0 empty empty Mod 15 23 0 10 #fce0c4 #000000
#000000 0 1;
#X obj 45 62 inlet;
#X obj 83 144 == 1;
#X obj 44 167 spigot;
#X obj 97 173 sel 0;
#X msg 97 195 1;
#X obj 134 253 *;
#X obj 134 215 t b f;
#X obj 45 86 * 0.9;
#X obj 45 110 + 0.1;
#X connect 0 0 10 0;
#X connect 3 0 5 0;
#X connect 3 0 7 0;
#X connect 4 0 11 0;
#X connect 5 0 6 1;
#X connect 6 0 9 0;
#X connect 7 0 8 0;
#X connect 8 0 9 0;
#X connect 9 0 1 0;
#X connect 9 0 2 0;
#X connect 10 0 9 0;
#X connect 10 1 9 1;
#X connect 11 0 12 0;
#X connect 12 0 6 0;
#X coords 0 -1 1 1 210 50 1 220 100;
#X restore 488 146 pd phasor;
#N canvas 32 25 450 374 phasor 0;
#X obj 225 103 hsl 200 30 -4 4 0 0 \$0-freq empty Pitch 20 16 0 15
#fce0c4 #000000 #000000 0 1;
#X obj 166 259 outlet;
#X obj 134 236 sel 0;
#X msg 223 66 1;
#X msg 192 66 0.5;
#X msg 254 66 2;
#X msg 154 66 -0.5;
#X msg 123 66 -1;
#X msg 92 66 -2;
#X obj 238 138 hradio 30 1 0 6 empty empty empty 0 -8 0 10 #fce0c4
#000000 #000000 0;
#X obj 90 25 sel 0 1 2 3 4 5;
#X text 242 172 -2;
#X text 272 172 -1;
#X text 297 172 -0.5;
#X text 330 172 0.5;
#X text 367 172 1;
#X text 397 172 2;
#X floatatom 223 197 6 0 0 0 - - -, f 6;
#X connect 0 0 17 0;
#X connect 2 1 1 0;
#X connect 3 0 0 0;
#X connect 4 0 0 0;
#X connect 5 0 0 0;
#X connect 6 0 0 0;
#X connect 7 0 0 0;
#X connect 8 0 0 0;
#X connect 9 0 10 0;
#X connect 10 0 8 0;
#X connect 10 1 7 0;
#X connect 10 2 6 0;
#X connect 10 3 4 0;
#X connect 10 4 3 0;
#X connect 10 5 5 0;
#X connect 17 0 2 0;
#X coords 0 -1 1 1 210 120 1 220 100;
#X restore 701 33 pd phasor;
#X obj 7 4 cnv 15 300 30 empty empty TIGGERS 20 12 0 20 #e0e0e0 #404040
0;
#X obj 277 4 cnv 15 300 30 empty empty POSITION 20 12 0 20 #e0e0e0
#404040 0;
#X obj 487 4 cnv 15 300 30 empty empty DURATION 20 12 0 20 #e0e0e0
#404040 0;
#X obj 702 4 cnv 15 210 30 empty empty PITCH 20 12 0 20 #e0e0e0 #404040
0;
#X obj 16 109 outlet;
#X obj 296 167 outlet;
#X obj 487 218 outlet;
#X obj 713 198 outlet;
#X connect 0 0 12 0;
#X connect 1 0 12 0;
#X connect 2 0 11 0;
#X connect 3 0 5 0;
#X connect 4 0 5 0;
#X connect 5 0 13 0;
#X connect 6 0 14 0;
#X coords 0 -1 1 1 920 200 2 0 0;
#X restore 22 307 pd controls;
#X text 324 212 Here we're using a mixture of modulators and random
generators to dynamically control the position \, length and density
of a cloud of sample segments \, or grains. This is just the tip of
the iceberg when it comes to granular synthesis \, but even with this
simple patch \, you can find a lot of sounds/textures!, f 88;
#X msg 22 512 1;
#X obj 25 698 output~;
#X connect 0 1 14 0;
#X connect 1 0 7 0;
#X connect 2 0 8 0;
#X connect 3 0 9 0;
#X connect 7 0 17 1;
#X connect 8 0 17 2;
#X connect 9 0 17 3;
#X connect 10 0 17 4;
#X connect 11 0 10 0;
#X connect 13 0 17 0;
#X connect 14 0 12 0;
#X connect 15 0 16 0;
#X connect 16 0 17 5;
#X connect 17 0 21 0;
#X connect 17 0 21 1;
#X connect 18 0 20 0;
#X connect 18 1 1 0;
#X connect 18 2 2 0;
#X connect 18 3 3 0;
#X connect 20 0 13 0;
#X restore 23 468 pd granularSynth;
